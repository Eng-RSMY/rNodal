---
title: "R Notebook"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include = FALSE, error=TRUE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      comment = "#>",
                      collapse = TRUE,
                      error = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      fig.align = 'center'
                      )
```


# Testing new deviation survey functions

## Two points
```{r}
library(rNodal)
library(dplyr)

geothermal_3p_txt <- c("
  TVD    temp
  0      60
  600    40
  9000   210
")

deviation_survey_6p_txt <- "
  MD      TVD 
  0	     0	 
  600	    600
  1005	 1000
  4075	 4000
  7700	 7500
  9275	 9000
"

# convert text table of geothermal gradient to dataframe
geotherm <- as_dataframe_geothermal_data(geothermal_3p_txt)
geothermal_3p_df <- geotherm$calc_geotherm_df
geothermal_3p_df

deviation_survey_6p <- calc_deviation_survey(deviation_survey_6p_txt, 
                                              reference = "horizontal")
deviation_survey_6p
```


```{r}
deviation_survey_6p <- calc_deviation_survey(deviation_survey_6p_txt, 
                                              reference = "vertical")
deviation_survey_6p
```

### convert text table of geothermal gradient to dataframe
```{r}
# convert text table of geothermal gradient to dataframe
geotherm <- as_dataframe_geothermal_data(geothermal_3p_txt)

geothermal_3p_df <- geotherm$calc_geotherm_df
geothermal_3p_df
```

### Build iteration table (two geothermal points)
```{r table-iter_table, rows.print=50}
geothermal_txt <- geothermal_3p_txt
deviation_survey_txt <- deviation_survey_6p_txt

ang_deviation_survey <- deviation_survey_6p
geothermal_df    <- geothermal_3p_df

iter_table <- build_iteration_table(ang_deviation_survey, 
                                    geotherm_df = geothermal_df, 
                                    depth_points = 40)
iter_table
```

```{r}
epsilon <- 1e-8

number_segments <- 40
geotherm_df    <- geothermal_3p_df
# TODO: validate columns in ang_deviation_survey. It must contain angles

# if depth_points < num_rows deviation_survey, only add geotherm temp

# TODO: validate the name of the columns of geotherm_df
ang_deviation_survey <- full_join(ang_deviation_survey, geotherm_df)
# print(ang_deviation_survey)

# add extra rows for calculations
# the original depths are included in the table as part of the total number of rows
ang_deviation_survey %>%
    select(TVD) %>%      # select TVD
    pull(TVD) %>%
    # {. -> tmp } %>%
    { tmp <- .                                  # assign to tmp
    mn <- min(tmp); mx <- max(tmp)          # create two objects min, max
    seq(mn, mx, length.out = number_segments+6) %>%
        c(., tmp) %>%
      # c(., tmp) 
        unique %>%
        sort()
    } %>%
    data.frame(tvd = .) %>%                  # convert vector to dataframe
    mutate(new_point = 99+row_number()) %>%  # add a column
    print() -> grown                         # create dataframe grown
```

```{r}
    # join the two tables (small original and grown with more rows) by TVD
    # table with lots of NAs
    right_join(ang_deviation_survey, grown, by = "tvd") %>%
        # mutate(delta.tvd = TVD - lag(TVD, default = 0))  %>%
        mutate(delta.tvd = tvd - lag(tvd, default = 0))  %>%
        print() -> joined

    # get MD, delta.md given TVD and angle at new intervals
    # & nrow(geotherm_df) < nrow(ang_deviation_survey)
    iter_table <- joined %>%
        mutate(given = ifelse(is.na(TVD), FALSE, TRUE)) %>%
        mutate(point = replace_na_with_last(point)) %>%
        mutate(radians = replace_na_from_bottom(radians)) %>%
        mutate(geo_grad = replace_na_from_bottom(geo_grad)) %>%
        mutate(dTVD = replace_na_from_bottom(dTVD)) %>%
        mutate(dtemp = replace_na_from_bottom(dtemp)) %>%
        mutate(temp = replace_na_with_last(temp)) %>%
        mutate(temp = dtemp + geo_grad * (tvd+dTVD) ) %>% # temp[[1]]: temperature at the top
        # if the TVD was given, do not calculate it, keep the original
        mutate(temp = ifelse(!given, dtemp + geo_grad * (tvd+dTVD), temp)) %>%
        mutate(delta.md = ifelse(cos(radians) <= epsilon,
                                 delta.tvd,
                                 delta.tvd / cos(radians))) %>%
        mutate(md = cumsum(delta.md)) %>%
        mutate(disp = delta.md * sin(radians)) %>%
        mutate(cum_disp = cumsum(disp)) %>%
        # mutate(temp = ifelse(is.na(temp), temp[[1]] + geo_grad * tvd, temp)) %>%
        select(new_point, tvd, md, radians, temp, geo_grad, given, TVD, MD,
               everything())

```


### Fluid temperature parameters using function
```{r}
# the standard well input
# Note that U (heat transfer coefficient is added at the end)

input_example <-  setWellInput(field.name = "HAGBR.MOD", 
                               well.name = "Oilwell_01_Dry", 
                               depth.wh = 0, 
                               depth.bh = 9275, 
                               diam.in = 4.052, 
                               GLR = 800, 
                               liq.rt = 983, wcut = 0.0, 
                               thp = 100, 
                               tht = 60, bht = 210, 
                               API = 37, 
                               oil.visc = 5.0, 
                               gas.sg = 0.76, 
                               wat.sg = 1.07, 
                               if.tens = 30, 
                               salinity = 23000, 
                               U = 8,
                               dev_survey = deviation_survey_6p_txt, 
                               geotherm = geothermal_3p_txt
                                
)

fluid_temp_params <- get_fluid_temp_parameters(input_example)
fluid_temp_params
```


# Calculate fluid temperatures, bottom to top

# Simplify the Ti calculation

  (Tei - geo_grad.nz * L * sin(theta.nz)) +
    (xTi * exp(-L/A) - Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A))
  
  xTi  =  -( (Tei - geo_grad.nz * L * sin(theta.nz)) -
    Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A)) ) / exp(-L/A)
    
  xTi * exp(-L/A) + (Tei - geo_grad.nz * L * sin(theta.nz)) -
    Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A)) 
    
  xTi = xTi * K1 + K2
    

  xTi = - ( (Tei - geo_grad.nz * L * sin(theta.nz)) +
     - Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A)) ) / exp(-L/A)


```{r function-that-returns-Ti, rows.print=50}
# what if we send a smaller dataframe with only the necessary columns
# the, the table is inverted in a function that returns only the 
# calculated column
# iter-table is produced by a function

# constants
U         <- fluid_temp_params$U
diam_ft   <- fluid_temp_params$diam.ft
mass_rate <- fluid_temp_params$mass.rate
cp_avg    <- fluid_temp_params$cp.avg
k         <- U * pi * diam_ft / mass_rate / cp_avg
A         <- 1 / k          # relaxation distance by Ramey. Shoham, pg 297

fT <- function(Ti, Tei, geo_grad.nz, L, theta.nz) {
  (Tei - geo_grad.nz * L * sin(theta.nz)) +
    (Ti - Tei) * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A))
}

calculate_Ti <- function(df) {
  df %>% 
    mutate(L = tvd[[n()]] - tvd) %>% 
    mutate(Tei = temp) %>% 
    mutate(theta = radians) %>% 
    arrange(desc(tvd)) %>% 
    mutate(theta.nz = ifelse(tvd == 0, lag(theta), theta)) %>%
    mutate(geo_grad.nz = ifelse(tvd == 0, lag(geo_grad), geo_grad)) %>% 
    { 
      x <- head(.,1)$Tei 
      sapply(1:nrow(.), function(i) { 
        x <<- fT(x, .$Tei[i], .$geo_grad.nz[i], .$L[i], .$theta.nz[i]) # global x
        .$Ti[i] <<- x  }) 
      . } %>%  # return internal dataframe
    select(-c(L, Tei, theta, geo_grad.nz, theta.nz)) %>% 
    arrange(tvd)    # go back to original order
}

iter_table_Ti <- iter_table %>% 
  mutate(Ti = NA) %>%       # add the fluid temperature variable Ti
  do(calculate_Ti(.)) %>%   # calculate Ti
  select(new_point, tvd, md, Ti, everything()) %>% 
  print()
```
