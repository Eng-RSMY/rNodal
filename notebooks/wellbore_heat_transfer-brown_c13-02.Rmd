---
title: "R Notebook"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include = FALSE, error=TRUE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      comment = "#>",
                      collapse = TRUE,
                      error = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      fig.align = 'center'
                      )
```


# Testing new deviation survey functions

```{r}
library(rNodal)
library(dplyr)

c13 <- new.env()
c13.input  <- new.env(parent = c13)
c13.output <- new.env(parent = c13.input)
```


## Two points
```{r}
with(c13.input, {
  geothermal_2p_txt <- c("
  TVD    temp
  0      120
  2670   150
")

  deviation_survey_2p_txt <- "
       TVD    MD
         0     0
      2670  2670
  "
  
  ### Fluid temperature parameters using function
  # the standard well input
  # Note that U (heat transfer coefficient is added at the end)
  input.example.C13 <- setWellInput(
                          field.name = "HAGBR.MOD",
                          well.name = "Brown_C13", 
                          depth.wh = 0, depth.bh = 2670, diam.in = 1.995, 
                          GLR = 500, liq.rt = 1000, wcut = 0.6, 
                          thp = 500, tht = 120, bht = 150, 
                          API = 22, gas.sg = 0.65, wat.sg = 1.07,
                          U = 17,
                          geotherm = geothermal_2p_txt,
                          dev_survey = deviation_survey_2p_txt
                          )
  
  fluid_temp_params <- get_fluid_temp_parameters(input.example.C13)
  print(fluid_temp_params)
})
```


### Build iteration table (two geothermal points)

```{r table-iter_table, rows.print=25}
with(c13.input, {
  # convert text table of geothermal gradient to dataframe
  geotherm <- as_dataframe_geothermal_data(geothermal_2p_txt)
  geothermal_2p_df <- geotherm$geothermal_calcs
  print(geothermal_2p_df)
  
  deviation_survey_2p <- calc_deviation_survey(deviation_survey_2p_txt, 
                                                reference = "horizontal")
  print(deviation_survey_2p)
  
  iter_table <- build_iteration_table(deviation_survey_2p, 
                                      geotherm_df = geothermal_2p_df, 
                                      step_size = 250)
  iter_table
})
```

# Calculate fluid temperatures, bottom to top

# Simplify the Ti calculation

  (Tei - geo_grad.nz * L * sin(theta.nz)) +
    (xTi * exp(-L/A) - Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A))
  
  xTi  =  -( (Tei - geo_grad.nz * L * sin(theta.nz)) -
    Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A)) ) / exp(-L/A)
    
  xTi * exp(-L/A) + (Tei - geo_grad.nz * L * sin(theta.nz)) -
    Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A)) 
    
  xTi = xTi * K1 + K2
    

  xTi = - ( (Tei - geo_grad.nz * L * sin(theta.nz)) +
     - Tei * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A)) ) / exp(-L/A)


```{r function-that-returns-Ti, rows.print=20}
# what if we send a smaller dataframe with only the necessary columns
# the, the table is inverted in a function that returns only the 
# calculated column
# iter-table is produced by a function
with(c13.input, {
  # constants
  U         <- fluid_temp_params$U
  diam_ft   <- fluid_temp_params$diam.ft
  mass_rate <- fluid_temp_params$mass.rate
  cp_avg    <- fluid_temp_params$cp.avg
})

with(c13.output, {
  k         <- U * pi * diam_ft / mass_rate / cp_avg
  A         <- 1 / k          # relaxation distance by Ramey. Shoham, pg 297
  
  # fluid temperature Ramey's function
  fT <- function(Ti, Tei, geo_grad.nz, L, theta.nz) {
    (Tei - geo_grad.nz * L * sin(theta.nz)) +
      (Ti - Tei) * exp(-L/A) +
      geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A))
  }
  
  calculate_Ti <- function(df) {
    df %>% 
      mutate(L = tvd[[n()]] - tvd) %>% 
      mutate(Tei = temp) %>% 
      mutate(theta = radians) %>% 
      arrange(desc(tvd)) %>% 
      mutate(theta.nz = ifelse(tvd == 0, lag(theta), theta)) %>%
      mutate(geo_grad.nz = ifelse(tvd == 0, lag(geo_grad), geo_grad)) %>% 
      { 
        x <- head(.,1)$Tei 
        sapply(1:nrow(.), function(i) { 
          x <<- fT(x, .$Tei[i], .$geo_grad.nz[i], .$L[i], .$theta.nz[i]) # global x
          .$Ti[i] <<- x  }) 
        . } %>%  # return internal dataframe
      # select(-c(L, Tei, theta, geo_grad.nz, theta.nz)) %>% 
      arrange(tvd)    # go back to original order
  }
  
  # calculate Ti and add it to iteration table
  iter_table_Ti <- iter_table %>% 
    mutate(Ti = NA) %>%       # add the fluid temperature variable Ti
    do(calculate_Ti(.)) %>%   # calculate Ti
    select(new_point, tvd, md, Ti, everything()) %>%
    print()
})
```

```{r eval=FALSE}
# write to CSV file
# write.csv(file = "c13-100000r.csv", x = iter_table_Ti, row.names = FALSE)
```

#

```{r}
# not giving the expected output
with(c13.input, {
  # constants
  U         <- fluid_temp_params$U
  diam_ft   <- fluid_temp_params$diam.ft
  mass_rate <- fluid_temp_params$mass.rate
  cp_avg    <- fluid_temp_params$cp.avg
})

with(c13.output, {
  k         <- U * pi * diam_ft / mass_rate / cp_avg
  A         <- 1 / k          # relaxation distance by Ramey. Shoham, pg 297
  

fT <- function(Ti, Te0, geo_grad.nz, L, theta.nz, A) {
  Tei = geo_grad.nz * L + Te0
  
  (Tei - geo_grad.nz * L * sin(theta.nz)) +
    (Ti - Tei) * exp(-L/A) +
    geo_grad.nz * A * sin(theta.nz) * (1 - exp(-L/A))
}

iter_table <- c13.output$iter_table_Ti
iter.L <- c13.output$iter_table_Ti$L
depth <- max(iter.L)
iter.grad <- c13.output$iter_table_Ti$geo_grad
Ti <- 150
Te0 <- 150

for (i in nrow(iter_table):1)
  cat(sprintf("%8.0f %8.0f %10.3f \n",
      iter_table$tvd[i], -iter_table$L[i],  
      fT(Ti = Ti, Te0 = Te0, iter_table$geo_grad.nz[i],
                              -iter_table$L[i], pi/2, A)))
})
```

