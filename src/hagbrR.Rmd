---
title: "Call and test HAGBR in pure R"
output: html_notebook
---

```{r}
# making HAGBR function work with only wellhead pressure
# all other parameters remain constant
source("HAGBR.R")

hagbr.1 <- function(p, t) {
  # modified HAGBR function to receive only pres, temp
  hagbr(diam.in = 1.995, 
      GLR = 75, 
      liq.rt = 758, 
      wcut = 0.10, 
      pres = p, 
      temp = t, 
      sgg = 0.7, API = 40, wat.sg = 1.05, 
      if.tens = 30, 
      oil.visc = 5)
}
```

```{r}
# get HAGBR results for different WHP and one temperature = 80 degF
pres <- c(200, 400, 800, 1000, 1100, 1500)
# hb <- hagbr.1(200)
list(sapply(pres, hagbr.1, t = 80))
```

```{r}
# Using mapply for quick calculations.
# get HAGBR results for different WHP and multiple temperatures. 
pres <- c(200, 400, 800, 1000, 1100, 1500)
temp <- c(80, 120, 180)

list(mapply(hagbr.1, pres, temp))
```



```{r rows.print=30}
# This iteration considers pressure and temperature changing
# iterate through well depths to calculate HAGBR
# using depths for any well
depth.wh <- 0
depth.bh <- 9700
depths <- seq.int(from = depth.wh, to = depth.bh, by = 100)
depths <- seq.int(from = depth.wh, to = depth.bh, length.out = 30)

nRow <- length(depths)

v = vector("list", nRow)
p0 <- 200                          # initial pressure. WHP
t0 <- 80                           # initial temperature

# new parameters
bht <- 180                                # bottomhole temperature
temp.grad <- (bht - t0) / depth.bh   # temperature gradient

t <- t0
p <- p0

for (i in seq_len(nRow)) {
  depth.ft <- depths[i]           # current depth
  dL <- depths[i+1] - depths[i]   # dL = next depth - current depth
  t <- t0 + temp.grad * depth.ft         # temperature at depth calculation
  v[[i]] <- c(depth.ft = depth.ft, 
              dL = dL, 
              pres.iter = p, 
              hagbr.1(p, t))
  # p <- p + v[[i]]$dp.dz * depths[i+1]
  p <- p + v[[i]]$dp.dz * dL
  
}

tbl <- data.table::rbindlist(v)     # add row to table
tbl
```


## create the tubing segments
```{r}
depth.wh <- 0
depth.bh <- 9700
n <- 30           # segments

h <- seq(from = depth.wh, to = depth.bh, length.out = n)
dh <- diff(h)
df <- data.frame(h)
# apply( df , 2 , diff )

# cum <- 0
# for (dhi in dh) {
#   
#   cat(cum, "\n")
#   cum <- cum + dhi
#   
# } 
library(data.table)

DT <- data.table(df)
DT <- DT[ , list(h, Diff = diff(h), pres = 0)  ]
DT[1, 3] <- 200
DT
```


## Conditions paper in spanish
```{r}
pwh = 100  # psi
tsup = 80  # deg F
ty = 170   # deg F
D = 5500   # ft
qb = 700   # BPD
ays = 0.10 
rgp = 600  # scf/stb
API = 32
Sgg = 0.60
Sgw = 1.0
dt = 2.5    # inches
e = 0.00050 # ft

```



































## sandbox

```{r}
## be careful with the format: most things in R are floats
## only integer-valued reals get coerced to integer.

sprintf("%s is %f feet tall\n", "Sven", 7.1)      # OK
try(sprintf("%s is %i feet tall\n", "Sven", 7.1)) # not OK
    sprintf("%s is %i feet tall\n", "Sven", 7  )  # OK
    sprintf("%s is %d feet tall\n", "Sven", 7  )  # OK

## use a literal % :

sprintf("%.0f%% said yes (out of a sample of size %.0f)", 66.666, 3)
```

```{r}

## various formats of pi :

sprintf("%f", pi)
sprintf("%.3f", pi)
sprintf("%1.0f", pi)
sprintf("%5.1f", pi)
sprintf("%05.1f", pi)
sprintf("%+f", pi)
sprintf("% f", pi)
sprintf("%-10f", pi) # left justified
sprintf("%e", pi)
sprintf("%E", pi)
sprintf("%g", pi)
sprintf("%g",   1e6 * pi) # -> exponential
sprintf("%.9g", 1e6 * pi) # -> "fixed"
sprintf("%G", 1e-6 * pi)
```


```{r}


## no truncation:
sprintf("%1.f", 101)

## re-use one argument three times, show difference between %x and %X
xx <- sprintf("%1$d %1$x %1$X", 0:15)
xx <- matrix(xx, dimnames = list(rep("", 16), "%d%x%X"))
noquote(format(xx, justify = "right"))

## More sophisticated:

sprintf("min 10-char string '%10s'",
        c("a", "ABC", "and an even longer one"))

## Platform-dependent bad example from qdapTools 1.0.0:
## may pad with spaces or zeroes.
sprintf("%09s", month.name)

n <- 1:18
sprintf(paste0("e with %2d digits = %.", n, "g"), n, exp(1))

## Using arguments out of order
sprintf("second %2$1.0f, first %1$5.2f, third %3$1.0f", pi, 2, 3)

## Using asterisk for width or precision
sprintf("precision %.*f, width '%*.3f'", 3, pi, 8, pi)

## Asterisk and argument re-use, 'e' example reiterated:
sprintf("e with %1$2d digits = %2$.*1$g", n, exp(1))

## re-cycle arguments
sprintf("%s %d", "test", 1:3)

## binary output showing rounding/representation errors
x <- seq(0, 1.0, 0.1); y <- c(0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1)
cbind(x, sprintf("%a", x), sprintf("%a", y))

```


```{r}
# example of using with() function
# see how objects have to be treated inside the with()
# to set and get values
useWith <- function(params) {
  with(as.list(params), {
       c <- a * b
       return(c)
  })
}
```

```{r}
params <- list(a = 10, b = 20)
useWith(params)
```

```{r}
#----------------------------------------------------------------------------------------#
# the model parameters:                                                                  #
#----------[------------------[------------[-----------------[---------------------------#
guoHB <- c(depth              = 9700,      # feet            depth of the well
           diam.in            = 1.995,     # inches          diameter of the tubing
           API                = 40,        #                 oil specific gravity in API
           oil.visc           = 5,         # cp              oil viscosity
           GLR                = 75,        # scf/stb         gas liquid ratio
           sgg                = 0.7,       # adim            gas specific gravity
           THP                = 200,       # psia            tubing head flowing pressure
           THT                = 80,        # Farenheit       wellhead temperature
           BHT                = 180,       # Farenheit       bottomhole flowing temperature
           liq.rt             = 758,       # stb/day         liquid rate = water + oil
           wcut               = 0.1,       # percent         watercut
           if.tens            = 30,        # dyn/cm          interfacial tension
           wat.sg             = 1.05       # adim            water specific gravity
  )

guoHB
```


